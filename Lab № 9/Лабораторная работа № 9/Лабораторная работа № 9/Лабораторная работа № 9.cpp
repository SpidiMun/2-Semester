#include <iostream>   // Стандартная библиотека
#include <fstream>    // Библиотека для работы с файлами
#include <string>     // Библиотека для работы с функцией getline()
using namespace std;  // Пространство имён std

int isConsolant(string str, int len) // Функция подсчёта согласных букв в строке
{
	int i, j;
	int counter = 0; // Счётчик кол-ва согласных букв
	char symbol[80] = "BbCcDdFfGgHhJjKkLlMmNnPpQqRrSsTtVvWwXxZzБбВвГгЖжЗзКкЛлМмНнПпРрСсТтФфХхЦцЧчШшЩщ"; // Массив согласных
	for (i = 0; i < len; i++) // Проход по всей длине строки
	{
		for (j = 0; j < 80; j++) // Проверка, символ - согласная буква?
		{
			if (str[i] == symbol[j]) // Если символ является согласной буквой, производится подсчёт символа
			{
				counter++;
			}
		}
	}
	cout << endl;
	return counter;
}

bool HasDoubles(string* words, int word_counter) // Проверка на наличие идентичных с первым словом слов в строке
{
	int i = 1;
	while (i < word_counter) // Проход по всем словам, нахождение слова, похожего на 1-ое (достаточно 1-го совпадения)
	{
		if (words[i] == words[0]) // Если такое слова найдено, то производится подсчёт слова
		{
			return true;
		}
		i++;
	}
	return false;
}

int WordsCounter(string row, int row_len)
{
	int i, counter = 0;
	for (i = 0; i < row_len; i++) // Подсчёт слов в строке
	{
		if (row[i] == ' ' || i == row_len - 1) // Нашелся пробел или конец строки, значит, найдено слово
		{
			while (i < row_len && row[i] == ' ') // Пропуск всех ненужных пробелов
			{
				i++;
			}
			counter++;
		}
	}
	return counter;
}

int main()
{
	system("chcp 1251>nul");
	string row;
	ifstream input("F1.txt"); // Файл ввода 
	ofstream output("F2.txt"); // Файл вывода
	if (input.is_open() == false || output.is_open() == false) // Если файлы не были открыты
	{
		cout << "Ошибка при открытии файлов. Закрытие программы..."; // Сообщение пользователю об ошибке
	}
	else 
	{
		remove("F2.txt"); // Очистка файла F2.txt, если в нем находились строки
		unsigned int row_len, i, word_counter;   // Длина строки, параметр, счётчик слов
		unsigned int row_number, j, row_counter; // Номер строки, параметр, счётчик строк в файле F2.txt
		string* words;                           // Слова в строке
		string word, end_row;                    // Записанное слово из строки, последняя найденная строка с индентичными словами
		row_number = 0;                          // Счётчик (изначально равно 0)
		row_counter = 0;                         // Счётчик строк равен нулю
		while (!input.eof()) // Пока не достигнут конец файла, происходит выполнение программы
		{
			row_number++;
			getline(input, row); // Получение из файла F1 строки и запись в row
			row_len = row.length(); // Вычисление длины полученной строки row
			if (row_len != 0) // Если длина строки не равна 0, то продолжение работы программы (Иначе переход на другую строку)
			{
				word_counter = 0; // Обнуление счётчика слов
				word_counter = WordsCounter(row, row_len); // Функция для подсчёта слов в строке
				words = new string[word_counter]; // Массив слов в строке размерностью кол-ва слов в строке
				word = ""; // Записываемое слово из строки (изначально отсутсвует)
				j = 0; // Номер записываемого слова
				for (i = 0; i < row_len; i++) // Проход по всей длине строки, запись слов в массив
				{
					if (row[i + 1] == ' ' || i == row_len - 1) // Если нашли следующий символ-пробел или конец строки, то производится запись слова в массив
					{
						word += row[i]; // Производится дозаписывание последнего символа в слове
						while (i < row_len && row[i + 1] == ' ') // Пропуск пробелов, если их несколько
						{
							i++;
						}
						words[j] = word; // Производится запись всего слова в массив
						word = ""; // Освобождается память для записи нового слова
						j++; // Следующий номер слова
					}
					else
					{
						word += row[i]; //Если не нашелся пробел или конец строки, то производится запись символа в слово
					}
				}
				if (HasDoubles(words, word_counter) == true) // Если индентичные слова были найдены, то продолжается работа со строкой
				{
					row_counter++; // Подсчёт строки с индентичными словами
					end_row = ""; // Очистка строки для записи новой
					output << row; // Запись строки в файл
					output << endl;
					end_row = row; // Запоминание найденной строки
				}
			}
		}
		input.close(); // Закрытие файл F1.txt (Больше с ним не работаем)
		if (row_counter != 0) // Если в файле F2.txt есть строки, то работаем с последней строкой в F2.txt
		{
			int consolant_counter; // Счётчик согласных букв в строке
			consolant_counter = isConsolant(end_row, end_row.length()); // Подсчёт кол-ва согласных в строке
			if (consolant_counter != 0)
			{
				cout << "В последнй строке файла F2.txt число согласных равно: " << consolant_counter << endl; // Вывод кол-ва согласных через консоль
			}
			else
			{
				cout << "В последней строке не было найдено согласных букв.";
			}
		}
		else // Если в файле F2.txt нет строк, то сообщается пользователю об отсутсвии строк в файле F2.txt 
		{
			cout << "В файле F2.txt нет строк\n";
		}
		output.close(); // Закрытие файла F2.txt
	}
}