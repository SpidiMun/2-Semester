#include <iostream>
#include <string>
#include <cstdlib>
using namespace std;

struct People																								// Структура "Люди"
{
	string Full_Name;																						// ФИО
	int Month;																								// Месяц рождения
	int Year;																								// Год рождения
	string Phone_Number;																					// Номер телефона
};

People* Create_Struct(People* str, int Size)																// Функция заполнения структуры
{
	cout << "Введите элементы множества:\n\n";
	int i;
	for (i = 0; i < Size; i++)																				// Каждая итерация отвечает за элемент структуры
	{
		cout << i + 1 << " элемент\n";
		cout << "ФИО: ";
		cin.ignore();
		getline(cin, str[i].Full_Name);																		// Заполнения поля "ФИО"
		cout << "Дата рождения(ММ.ГГГГ) в числовом виде\n";
		cout << "Месяц: ";
		cin >> str[i].Month;																				// Заполнения поля "Месяц рождения"
		cout << "Год: ";
		cin >> str[i].Year;																					// Заполнения поля "Год рождения"
		while ((str[i].Year <= 0) || (str[i].Month < 1 || str[i].Month > 12))								// Введена некорректная дата. Необходимо перезаписать поля элемента
		{
			cout << "Некорректно введена дата рождения. Введите правильную дату рождения\n\n";
			cout << "Месяц: ";
			cin >> str[i].Month;																			// Заполнения поля "Месяц рождения"
			cout << "Год: ";
			cin >> str[i].Year;																				// Заполнения поля "Год рождения"
		}
		cout << "Номер телефона: ";
		cin.ignore();
		getline(cin, str[i].Phone_Number);																	// Заполнения поля "Номер телефона"
	}
	cout << endl;
	return str;
}

void Print_One_Element_In_Struct(People* str, int Index)													// Функция вывода одного элемента структуры
{
	cout << "ФИО: " << str[Index].Full_Name << endl;														// Вывод поля "ФИО"
	if (str[Index].Month < 10)																				// Если месяц состоит из одной цифры
	{
		cout << "Дата рождения: " << '0' << str[Index].Month << '.' << str[Index].Year << endl;				// Вывод полей "Месяц рождения" и "Год рождения" (0М.ГГГГ)
	}
	else																									// Если месяц состоит из двух цифр 
	{
		cout << "Дата рождения: " << str[Index].Month << '.' << str[Index].Year << endl;					// Вывод полей "Месяц рождения" и "Год рождения" (ММ.ГГГГ)
	}
	cout << "Номер телефона: " << str[Index].Phone_Number << endl << endl;									// Вывод поля "Номер телефона"
}

void Print_Struct(People* str, int Size)																	// Функция вывода элементов структуры
{
	cout << endl;
	cout << "Вывожу множество...\n\n";
	int i;
	for (i = 0; i < Size; i++)																				// Цикл для вывода элементов по одному 
	{
		cout << i + 1 << " элемент\n";																		// Вывод номера элемента
		Print_One_Element_In_Struct(str, i);																// Вывод по одному элементу через цикл
	}
}

string String_Data(int* Data)																				// Функция получения даты рождения в символьном формате 
{
	int i;																									// Параметр
	string RowData;																							// Переменная для записи даты рождения в символьном формате
	for (i = 0; i < 7; i++)
	{
		switch (Data[i])																					// Сравнение каждого элемента массива цифр даты рождения
		{
		case 0:
		{
			RowData += '0';																					// Цифра 0
			break;
		}
		case 1:																								// Цифра 1
		{
			RowData += '1';
			break;
		}
		case 2:																								// Цифра 2
		{
			RowData += '2';
			break;
		}
		case 3:																								// Цифра 3
		{
			RowData += '3';
			break;
		}
		case 4:																								// Цифра 4
		{
			RowData += '4';
			break;
		}
		case 5:																								// Цифра 5
		{
			RowData += '5';
			break;
		}
		case 6:																								// Цифра 6
		{
			RowData += '6';
			break;
		}
		case 7:																								// Цифра 7
		{
			RowData += '7';
			break;
		}
		case 8:																								// Цифра 8
		{
			RowData += '8';
			break;
		}
		case 9:																								// Цифра 9
		{
			RowData += '9';
			break;
		}
		default:																							// Нашлась цифра -1 (это обозначение точки)
		{
			RowData += '.';																					// Записываем точку
			break;
		}
		}
	}
	return RowData;
}

string Get_String_Massive(People Element)																	// Функция, которая превращает дату рождения из численного значения в строку
{
	int IntData[] = { 0, 0, 0, 0, 0, 0, 0 };																// Массив для записи цифр даты рождения
	int i = 1;																								// Параметр
	if (Element.Month < 10)																					// Если месяц состоит из одной цифры
	{
		IntData[0] = 0;																						// Первая цифра месяца ноль
		IntData[1] = Element.Month;																			// Следующая цифра и есть полный месяц
	}
	else																									// Если месяц состоит из двух цифр
	{
		while (Element.Month > 0)
		{
			IntData[i] = Element.Month % 10;																// Вторая цифра месяца из разряда единицы
			i--;																							// Переход к разряду десятков
			Element.Month = Element.Month / 10;																// Первая цифра месяца из разряда десятка
		}
	}
	IntData[2] = -1;																						// Третий символ в записи даты является точка
	i = 6;																									// Переход на последний элемент массива цифр даты
	while (Element.Year > 0)
	{
		IntData[i] = Element.Year % 10;																		// Запись цифры года
		i--;																								// Переход на старший разряд
		Element.Year = Element.Year / 10;																	// Отсечение последней цифры числа
	}
	string StringData;																						// Переменная для записи даты в символьном формате
	StringData = String_Data(IntData);																		// Запись даты в символьном формате
	return StringData;
}

void Substring_Search(People* str, int Size)																// Функция Метода Прямого Поиска
{
	cout << "==================== ПРЯМОЙ ПОИСК ПОДСТРОКИ В СТРОКЕ ====================\n\n";
	cout << "Введите подстроку (следуйте написанию даты MM.ГГГГ, иначе элемент не найдется)\n\nШаблон: ";
	string Substr;																							// Подстрока (шаблон)
	cin >> Substr;
	while (Substr.size() == 0)																				// Проверка на длину шаблона
	{
		cout << "\nПодстрока не была введена. Введите подстроку: ";
		cin >> Substr;
	}
	cout << "\nПроизвожу поиск подстроки...\n\n";
	int i, j, Index;																						// 1-й параметр, 2-й параметр, индекс элемента
	int strlen, substrlen;																					// Длина строки, длина шаблона
	substrlen = Substr.size();																				// Вычисляем длину шаблона (один на все элементы)
	string RowData;																							// Запись даты в строковом формате
	bool Find;																								// Переменная отвечает, нашлось ли совпадение шаблона и строки в одном элементе
	int FindCounter = 0;																					// Количество совпадений в множестве
	for (Index = 0; Index < Size; Index++)
	{
		Find = false;																						// При сравнении нового элемента с шаблоном шаблон не найден
		RowData = Get_String_Massive(str[Index]);															// Записываем дату в строковом формате
		strlen = RowData.size();																			// Вычисляем длину строки (даты)
		for (i = 0; i < strlen - substrlen + 1; i++)														// Проход по строке
		{
			for (j = 0; j < substrlen; j++)																	// Сравнение каждого символа шаблона и строки
			{
				if (Substr[j] != RowData[i + j])															// Если нашлось хоть одно несовпадение
				{
					break;																					// Переход к следующему элементу
				}
				else																						// Если символы совпадают
				{
					if (j == substrlen - 1 && Find == false)												// Если совпали последний символ шаблона и символ строки и до этого совпадения у них не было
					{
						Find = true;																		// Указываем, что совпадение в элементе нашлось
						FindCounter++;																		// Делаем подсчет элемента
						cout << "Элемент в множестве найден. Вывожу элемент множества под номером " << Index + 1 << endl << endl;
						Print_One_Element_In_Struct(str, Index);											// Выводим данный элемент
					}
				}
			}
		}
	}
	if (FindCounter == 0)																					// Если не было найдено ни одного совпадения в множестве
	{
		cout << "Не найдено ни одного элемента в множестве. Завершение поиска...\n\n";
	}
	cout << "=========================================================================\n\n";
}

int* Pi_Function(string Substring)																			// Функция формирвания префикс-функции (массив сдвига)
{
	int* Pi = new int[Substring.length()];																	// Пи-функция (это и есть масссив сдвига)
	int i = 1, j = 0;
	Pi[0] = 0;																								// Первый символ всегда имеет сдвиг 0 
	while (i < Substring.length())
	{
		if (Substring[j] == Substring[i])
		{
			Pi[i] = j + 1;																					// Сдвиг на позицию этого символа
			i++;
			j++;
		}
		else
		{
			if (j == 0)															
			{
				Pi[i] = 0;																					// Сдиг на первый символ
				i++;																						
			}
			else
			{
				j = Pi[j - 1];																				// Сдвиг на первое вхождение символа												
			}
		}
	}
	return Pi;																								// Возвращаем массив сдвига
}

void KMP_Search(People* str, int Size)																		// Функция Метода Кнута, Морриса, Пратта
{
	cout << "================= ПОИСК МЕТОДОМ КНУТА, МОРРИСА, ПРАТТА =================\n\n";
	cout << "Введите шаблон (следуйте написанию даты MM.ГГГГ, иначе элемент не найдется)\n";
	string Substr;																							// Подстрока (шаблон)
	cin >> Substr;
	while (Substr.size() == 0)
	{
		cout << "Шаблон не был введен. Введите шаблон: ";
		cin >> Substr;
	}
	cout << "\nПроизвожу поиск шаблона...\n\n";
	int* Pi = new int[Substr.length()];
	Pi = Pi_Function(Substr);																				// Создание таблицы сдвига
	int i, j, Index;
	int strlen, substrlen;																					// Длина строки, длина шаблона
	substrlen = Substr.size();																				// Вычисляем длину шаблона (один на все элементы)
	string RowData;																							// Запись даты в строковом формате
	bool Find;																								// Переменная отвечает, нашлось ли совпадение шаблона и строки в одном элементе
	int FindCounter = 0;																					// Количество совпадений в множестве
	for (Index = 0; Index < Size; Index++)
	{
		i = 0;
		j = 0;
		Find = false;																						// При сравнении нового элемента с шаблоном шаблон не найден
		RowData = Get_String_Massive(str[Index]);															// Записываем дату в строковом формате
		strlen = RowData.size();																			// Вычисляем длину строки (даты)
		while (i < strlen)																					// Проход по строке
		{
			if (Substr[j] == RowData[i])
			{
				if (j == substrlen - 1 && Find == false)													// Если совпали последний символ шаблона и символ строки и до этого совпадения у них не было
				{
					Find = true;																			// Указываем, что совпадение в элементе нашлось
					FindCounter++;																			// Делаем подсчет элемента
					cout << "Элемент в множестве найден. Вывожу элемент множества под номером " << Index + 1 << endl << endl;
					Print_One_Element_In_Struct(str, Index);												// Выводим данный элемент
				}
				else																						// Если совпали не последний символ шаблона и символ строки (или совпадение уже произошло)
				{
					j++;				
					i++;
				}
			}
			else
			{
				if (j == 0)																					// Если символ первый в шаблоне
				{
					i++;																					// Переходим на следующий символ
				}
				else																						// Если смивол не первый в шаблоне
				{
					j = Pi[j - 1];																			// Сдигаем согласно префикс-функции
				}
			}
		}
	}
	if (FindCounter == 0)
	{
		cout << "Не найдено ни одного элемента в множестве. Завершение поиска...\n\n";
	}
	cout << "========================================================================\n\n";
}

void BM_Search(People* str, int Size)																		// Функция Метода Бойера-Мура
{
	cout << "================= ПОИСК МЕТОДОМ БОЙЕРА-МУРА =================\n\n";
	cout << "Введите шаблон (следуйте написанию даты MM.ГГГГ, иначе элемент не найдется)\n";
	string Substr;																							// Подстрока (шаблон)
	cin >> Substr;
	while (Substr.size() == 0)
	{
		cout << "Шаблон не был введен. Введите шаблон: ";
		cin >> Substr;
	}
	cout << "\nПроизвожу поиск шаблона...\n\n";
	int i, Index;
	int strlen, substrlen;		
	substrlen = Substr.size();																				// Вычисляем длину шаблона (один на все элементы)// Длина строки, длина шаблона
	string RowData;																							// Запись даты в строковом формате
	bool Find;																								// Переменная отвечает, нашлось ли совпадение шаблона и строки в одном элементе
	int FindCounter = 0;																					// Количество совпадений в множестве
	for (Index = 0; Index < Size; Index++)
	{
		Find = false;																						// При сравнении нового элемента с шаблоном шаблон не найден
		RowData = Get_String_Massive(str[Index]);															// Записываем дату в строковом формате
		strlen = RowData.size();																			// Вычисляем длину строки (даты)
		int position;																						// Переменная, показывает, на каком символе в сравнении мы находимся
		int Shift[256];																						// Массив смещения
		for (i = 0; i < 256; i++)
		{
			Shift[i] = substrlen;																			// Сначала необходимо для каждого элемента задать смещение равное длине шаблона
		}
		for (i = substrlen - 2; i >= 0; i--)																// Корректировка массива
		{
			if (Shift[int(unsigned char(Substr[i]))] == substrlen)											// Для символов шаблона находим их ячейку в массиве
			{
				Shift[int(unsigned char(Substr[i]))] = substrlen - i - 1;									// И присваиваем необходимое значение
			}
		}
		position = substrlen - 1;																			// Позиция последнего элемента шаблона относительно строки
		while (position < strlen)																			// Пока строка не закончилась
		{
			if (Substr[substrlen - 1] != RowData[position])													// Если символы не совпали
			{
				position += Shift[int((unsigned char)RowData[position])];									// Сдвиг шаблона относительно строки
			}
			else																							// Если обнаружено совпадение
			{
				for (i = substrlen - 1; i >= 0; i--)														// Проверяем по очереди каждый элемент
				{
					if (Substr[i] != RowData[position - substrlen + i + 1])									// Если обнаружено несовпадение
					{
						position += Shift[int((unsigned char)RowData[position])];							// Сдвиг
						break;																				// Прерывание текущей проверки
					}
					else if (i == 0)																		// Если поиск окончен (Шаблон нашелся в подстроке)
					{
						Find = true;																		// Указываем, что совпадение в элементе нашлось
						FindCounter++;																		// Делаем подсчет элемента
						cout << "Элемент в множестве найден. Вывожу элемент множества под номером " << Index + 1 << endl << endl;
						Print_One_Element_In_Struct(str, Index);											// Выводим данный элемент
						break;
					}
				}
			}
		}
	}
	if (FindCounter == 0)
	{
		cout << "Не найдено ни одного элемента в множестве. Завершение поиска...\n\n";
	}
	cout << "========================================================================\n\n";
}

int Menu()																									// Функция вывода меню
{
	cout << "==================== МЕНЮ ====================\n\n";
	cout << "Выберите функцию, которую хотите произвести:\n\n";
	cout << "1. Вывод множества данных\n";
	cout << "2. Произвести поиск элемента(-ов) по ключу Методом Поиска Кнутта, Морриса, Пратта\n";
	cout << "3. Произвести поиск элемента(-ов) по ключу Методом Поиска Бойера-Мура\n";
	cout << "4. Произвести поиск элемента(-ов) по ключу Методом Прямого Поиска\n";
	cout << "5. Выход из программы\n\n";
	cout << "Напишите в консоль номер функции, которую вы хотите произвести: ";
	int Function;																							// Переменная, которая хранит номер действия
	cin >> Function;
	while (Function < 1 || Function > 5)
	{
		cout << "Такого номера функции нет. Напишите в консоль новый номер функции:\n\n";
		cout << "1. Вывод множества данных\n";
		cout << "2. Произвести поиск элемента(-ов) по ключу Методом Поиска Кнутта, Морриса, Пратта\n";
		cout << "3. Произвести поиск элемента(-ов) по ключу Методом Поиска Бойера-Мура\n";
		cout << "4. Произвести поиск элемента(-ов) по ключу Методом Прямого Поиска\n";
		cout << "5. Выход из программы\n\n";
		cout << "Напишите в консоль номер функции, которую вы хотите произвести: ";
		cin >> Function;
	}
	cout << endl;
	cout << "==============================================\n\n";
	return Function;
}

int main()
{
	system("chcp 1251>nul");
	int N;																				// Количество элементов в множестве
	cout << "Введите количество элементов в множестве: ";
	cin >> N;
	while (N <= 0)
	{
		cout << "Число элементов в множестве не может быть меньше единицы. Введите новое количество элементов: ";
		cin >> N;
	}
	People* Man = new People[N];														// Выделение памяти под множество
	Man = Create_Struct(Man, N);														// Заполнение структуры элементами
	int Action = -1;																	// Переменная, которая отвечает за выполнения действия
	while (Action != 0)																	// Пока не вышли из программы
	{
		Action = Menu();																// Запрашиваем выполняемое действие
		switch (Action)
		{
		case 1:																			// Вывод множества
		{
			Print_Struct(Man, N);
			break;
		}
		case 2:																			// Метод Поиска Бойера-Мура
		{
			BM_Search(Man, N);
			break;
		}
		case 3:																			// Метод Поиска Кнута, Морриса, Пратта
		{
			KMP_Search(Man, N);
			break;
		}
		case 4:																			// Метод Прямого Поиска Подстроки в Строке
		{
			Substring_Search(Man, N);
			break;
		}
		case 5:																			// Выход из программы
		{
			cout << "Выход из программы...\n";
			Action = 0;
			break;
		}
		}
	}
}