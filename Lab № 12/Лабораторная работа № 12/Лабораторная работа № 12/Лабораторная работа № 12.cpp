#include <iostream>
#include <string>
#include <cstdlib>
using namespace std;

struct People																								// Структура "Люди"
{
	string Full_Name;																						// ФИО
	int Month;																								// Месяц рождения
	int Year;																								// Год рождения
	string Phone_Number;																					// Номер телефона
};

People* Create_Struct(People* str, int Size)																// Функция заполнения структуры
{
	cout << "Введите элементы множества:\n\n";
	int i;
	for (i = 0; i < Size; i++)																				// Каждая итерация отвечает за элемент структуры
	{
		cout << i + 1 << " элемент\n";
		cout << "ФИО: ";
		cin.ignore();
		getline(cin, str[i].Full_Name);																		// Заполнения поля "ФИО"
		cout << "Дата рождения(ММ.ГГГГ) в числовом виде\n";
		cout << "Месяц: ";
		cin >> str[i].Month;																				// Заполнения поля "Месяц рождения"
		cout << "Год: ";
		cin >> str[i].Year;																					// Заполнения поля "Год рождения"
		while ((str[i].Year <= 0) || (str[i].Month < 1 || str[i].Month > 12))								// Введена некорректная дата. Необходимо перезаписать поля элемента
		{
			cout << "Некорректно введена дата рождения. Введите правильную дату рождения\n\n";
			cout << "Месяц: ";
			cin >> str[i].Month;																			// Заполнения поля "Месяц рождения"
			cout << "Год: ";
			cin >> str[i].Year;																				// Заполнения поля "Год рождения"
		} 
		cout << "Номер телефона: ";
		cin.ignore();
		getline(cin, str[i].Phone_Number);																	// Заполнения поля "Номер телефона"
	}
	cout << endl;
	return str;
}

void Print_One_Element_In_Struct(People* str, int Index)													// Функция вывода одного элемента структуры
{
	cout << "ФИО: " << str[Index].Full_Name << endl;														// Вывод поля "ФИО"
	if (str[Index].Month < 10)																				// Если месяц состоит из одной цифры
	{
		cout << "Дата рождения: " << '0' << str[Index].Month << '.' << str[Index].Year << endl;				// Вывод полей "Месяц рождения" и "Год рождения" (0М.ГГГГ)
	}
	else																									// Если месяц состоит из двух цифр 
	{
		cout << "Дата рождения: " << str[Index].Month << '.' << str[Index].Year << endl;					// Вывод полей "Месяц рождения" и "Год рождения" (ММ.ГГГГ)
	}
	cout << "Номер телефона: " << str[Index].Phone_Number << endl << endl;									// Вывод поля "Номер телефона"
}

void Print_Struct(People* str, int Size)																	// Функция вывода элементов структуры
{
	cout << endl;
	cout << "Вывожу множество...\n\n";
	int i;
	for (i = 0; i < Size; i++)																				// Цикл для вывода элементов по одному 
	{
		cout << i + 1 << " элемент\n";																		// Вывод номера элемента
		Print_One_Element_In_Struct(str, i);																// Вывод по одному элементу через цикл
	}
}

void Linear_Search(People* str, int Size)																	// Функция линейного поиска
{
	cout << "==================== ЛИНЕЙНЫЙ ПОИСК ДАННЫХ ====================\n\n";
	People Key;																								// Переменная для записи даты рождения
	cout << "Введите дату рождения для поиска элемента по вводимому ключу\n";
	cout << "Месяц: ";																						// Заполнения поля "Месяц рождения"
	cin >> Key.Month;																						
	cout << "Год: ";
	cin >> Key.Year;																						// Заполнения поля "Год рождения"
	cout << endl;
	cout << "Произвожу поиск данных по ключу линейным методом...\n\n";
	int i = 0;																								// Параметр-индекс элемента
	bool Find = false;																						// Переменная отвечает, нашлось ли совпадение ключа и одного элемента
	while (i < Size)																						
	{
		if (str[i].Month == Key.Month && str[i].Year == Key.Year)											// Если месяц и год ключа совпал с месяцем и годом элемента
		{
			Find = true;																					// Указываем, что элемент нашёлся
			cout << "Найден элемент под номером " << i + 1 << ". Вывожу данные элемента...\n\n";
			Print_One_Element_In_Struct(str, i);															// Вывод данного элемента
		}
		i++;																								// Переход на следующий элемент
	}
	if (Find == false)																						// Если совпадений не нашлось во всем множестве
	{
		cout << "Не удалось найти ни одного элемента по заданному ключу. Завершение работы с методом...\n\n";
	}
	cout << "===============================================================\n\n";
}

long int* Get_Data_In_Number(People* str, int Size)															// Функция получения даты рождения в числовом формате
{
	long int* Data = new long int[Size];																	// Формирование массива для каждой даты рождения в числовом формате
	int i;
	for (i = 0; i < Size; i++)															
	{
		Data[i] = str[i].Year * 100 + str[i].Month;															// Числовая форма даты рождения: год * 100 + месяц
	}
	return Data;
}

People* Sort_Struct(People* str, int Size)																	// Функция сортировки структуры (Сортировка Методом Выбора)
{
	cout << "==================== СОРТИРОВКА МНОЖЕСТВА ====================\n\n";
	cout << "Произвожу сортировку множества...\n\n";
	int i, j;																								// 1-й параметр, 2-й параметр
	int min, index;																							// Минимальный элемент массива дат, индекс элемента
	long int* Data = Get_Data_In_Number(str, Size);															// Формирование массива для всех дат рождения в числовой форме
	People transfer;																						// Дополнительная переменная для сортировки (хранит минимальный элемент множества)
	for (i = 0; i < Size - 1; i++)																			// Сортируем методом выбора
	{
		transfer = str[i];																					// Минимальный элемент - первый элемент неотсортированной части множества
		min = Data[i];																						// Минимальный элемент - первый элемент неотсортированной части массива дат
		index = i;																							// Индекс минимального элемента
		for (j = i + 1; j < Size; j++)																		// Проход по другим элементам множества
		{
			if (Data[j] < min)																				// Если нашёлся элемент меньше нимимального
			{
				min = Data[j];																				// Новый минимальный элемент массива дат
				transfer = str[j];																			// Новый минимальный элемент множества
				index = j;																					// Новый индекс минимального элемента
			}
		}
		Data[index] = Data[i];																				// Перестановка первого элемента неотсортированной части массива дат с минимальным
		Data[i] = min;																						// Заносим первый минимальный элемент массива дат в отсортированную часть
		str[index] = str[i];																				// Перестановка первого элемента неотсортированной части множества с минимальным
		str[i] = transfer;																					// Заносим первый минимальный элемент множества в отсортированную часть
	}
	cout << "==============================================================\n\n";
	return str;
}

void Interpolar_Search(People* str, int Size)																// Функция интерполяционного поиска
{
	cout << "==================== ИНТЕРПОЛЯЦИОННЫЙ ПОИСК ДАННЫХ ====================\n\n";
	cout << "Введите ключ поиска (дата рождения MM.ГГГГ):\n";
	People Struct_Key;																						// Ключ поиска (хранит дату рождения)
	cout << "Месяц: ";
	cin >> Struct_Key.Month;																				// Заполнения поля "Месяц рождения"
	cout << "Год: ";
	cin >> Struct_Key.Year;																					// Заполнения поля "Год рождения"
	cout << endl;
	int Digit_Key = Struct_Key.Year * 100 + Struct_Key.Month;												// Числовая форма даты рождения ключа: год * 100 + месяц 
	cout << "Произвожу поиск данных по ключу интерполяционным методом...\n\n";
	int i = 0;																								// Параметр
	long int* Data = Get_Data_In_Number(str, Size);															// Формирование массива для каждой даты рождения в числовой форме
	int mid, left = 0, right = Size - 1;																	// Индекс искомого элемента, левая граница рассматриваемого множества, правая граница рассматриваемого множества
	bool Find = false, COUT = false;																		// Переменная отвечает, нашлось ли совпадение ключа и одного элемента, переменная отвечает, нужно ли выводить элемент 
	while (Data[left] <= Digit_Key && Data[right] >= Digit_Key)
	{
		mid = left + ((Digit_Key - Data[left]) * (right - left)) / (Data[right] - Data[left]);				// Вычисление индекса искомого элемента
		if (Data[mid] < Digit_Key)																			// Если элемент меньше ключа
		{
			left = mid + 1;																					// Новая левая граница 
		}
		else
		{
			if (Data[mid] > Digit_Key)																		// Если элемент больше ключа
			{
				right = mid - 1;																			// Новая правая граница 
			}
			else																							// Если элемент совпал с ключом
			{
				Find = true;																				// Указываем, что совпадение обнаружено								
				COUT = true;																				// Повторно выводить элемент не нужно
				cout << "Элемент в множестве найден. Вывожу элемент множества под номером " << mid + 1 << endl << endl;
				Print_One_Element_In_Struct(str, mid);														// Вывод данного элемента
				break;
			}
		}	
	}
	if (Data[left] == Digit_Key && COUT == false)															// Если обнаружено совпадение и вывод не произошел
	{
		cout << "Элемент в множестве найден. Вывожу элемент множества под номером " << left + 1 << endl << endl;
		Print_One_Element_In_Struct(str, left);																// Вывод 
	}
	else																									
	{
		if (Find == false)																					// Если совпадения не обнаружено				
		{
			cout << "Не удалось найти ни одного элемента по заданному ключу. Завершение работы с методом...\n\n";
		}
	}
	cout << "=======================================================================\n\n";
}

string String_Data(int* Data)																				// Функция получения даты рождения в символьном формате 
{
	int i;																									// Параметр
	string RowData;																							// Переменная для записи даты рождения в символьном формате
	for (i = 0; i < 7; i++)
	{
		switch (Data[i])																					// Сравнение каждого элемента массива цифр даты рождения
		{
		case 0:
		{
			RowData += '0';																					// Цифра 0
			break;
		}
		case 1:																								// Цифра 1
		{
			RowData += '1';
			break;
		}
		case 2:																								// Цифра 2
		{
			RowData += '2';
			break;
		}
		case 3:																								// Цифра 3
		{
			RowData += '3';
			break;
		}
		case 4:																								// Цифра 4
		{
			RowData += '4';
			break;
		}
		case 5:																								// Цифра 5
		{
			RowData += '5';
			break;
		}
		case 6:																								// Цифра 6
		{
			RowData += '6';
			break;
		}
		case 7:																								// Цифра 7
		{
			RowData += '7';
			break;
		}
		case 8:																								// Цифра 8
		{
			RowData += '8';
			break;
		}
		case 9:																								// Цифра 9
		{
			RowData += '9';
			break;
		}
		default:																							// Нашлась цифра -1 (это обозначение точки)
		{
			RowData += '.';																					// Записываем точку
			break;
		}
		}
	}
	return RowData;
}

string Get_String_Massive(People Element)																	// Функция, которая превращает дату рождения из численного значения в строку
{
	int IntData[] = { 0, 0, 0, 0, 0, 0, 0 };																// Массив для записи цифр даты рождения
	int i = 1;																								// Параметр
	if (Element.Month < 10)																					// Если месяц состоит из одной цифры
	{
		IntData[0] = 0;																						// Первая цифра месяца ноль
		IntData[1] = Element.Month;																			// Следующая цифра и есть полный месяц
	}
	else																									// Если месяц состоит из двух цифр
	{
		while (Element.Month > 0)
		{
			IntData[i] = Element.Month % 10;																// Вторая цифра месяца из разряда единицы
			i--;																							// Переход к разряду десятков
			Element.Month = Element.Month / 10;																// Первая цифра месяца из разряда десятка
		}
	}
	IntData[2] = -1;																						// Третий символ в записи даты является точка
	i = 6;																									// Переход на последний элемент массива цифр даты
	while (Element.Year > 0)
	{
		IntData[i] = Element.Year % 10;																		// Запись цифры года
		i--;																								// Переход на старший разряд
		Element.Year = Element.Year / 10;																	// Отсечение последней цифры числа
	}
	string StringData;																						// Переменная для записи даты в символьном формате
	StringData = String_Data(IntData);																		// Запись даты в символьном формате
	return StringData;
}

void Substring_Search(People* str, int Size)																// Функция Метода Прямого Поиска
{
	cout << "==================== ПРЯМОЙ ПОИСК ПОДСТРОКИ В СТРОКЕ ====================\n\n";
	cout << "Введите подстроку (следуйте написанию даты MM.ГГГГ, иначе элемент не найдется)\n\nШаблон: ";
	string Substr;																							// Подстрока (шаблон)
	cin >> Substr;
	while (Substr.size() == 0)																				// Проверка на длину шаблона
	{
		cout << "\nПодстрока не была введена. Введите подстроку: ";
		cin >> Substr;
	}
	cout << "\nПроизвожу поиск подстроки...\n\n";
	int i, j, Index;																						// 1-й параметр, 2-й параметр, индекс элемента
	int strlen, substrlen;																					// Длина строки, длина шаблона
	substrlen = Substr.size();																				// Вычисляем длину шаблона (один на все элементы)
	string RowData;																							// Запись даты в строковом формате
	bool Find;																								// Переменная отвечает, нашлось ли совпадение шаблона и строки в одном элементе
	int FindCounter = 0;																					// Количество совпадений в множестве
	for (Index = 0; Index < Size; Index++)
	{
		Find = false;																						// При сравнении нового элемента с шаблоном шаблон не найден
		RowData = Get_String_Massive(str[Index]);															// Записываем дату в строковом формате
		strlen = RowData.size();																			// Вычисляем длину строки (даты)
		for (i = 0; i < strlen - substrlen + 1; i++)														// Проход по строке
		{
			for (j = 0; j < substrlen; j++)																	// Сравнение каждого символа шаблона и строки
			{
				if (Substr[j] != RowData[i + j])															// Если нашлось хоть одно несовпадение
				{
					break;																					// Переход к следующему элементу
				}
				else																						// Если символы совпадают
				{
					if (j == substrlen - 1 && Find == false)												// Если совпали последний символ шаблона и символ строки и до этого совпадения у них не было
					{
						Find = true;																		// Указываем, что совпадение в элементе нашлось
						FindCounter++;																		// Делаем подсчет элемента
						cout << "Элемент в множестве найден. Вывожу элемент множества под номером " << Index + 1 << endl << endl;
						Print_One_Element_In_Struct(str, Index);											// Выводим данный элемент
					}
				}
			}
		}
	}
	if (FindCounter == 0)																					// Если не было найдено ни одного совпадения в множестве
	{
		cout << "Не найдено ни одного элемента в множестве. Завершение поиска...\n\n";
	}
	cout << "=========================================================================\n\n";
}

int Menu()																									// Функция вывода меню
{
	cout << "==================== МЕНЮ ====================\n\n";
	cout << "Выберите функцию, которую хотите произвести:\n\n";
	cout << "1. Вывод множества данных\n";
	cout << "2. Сортировка множества\n";
	cout << "3. Произвести поиск элемента(-ов) по ключу Методом Линейного Поиска\n";
	cout << "4. Произвести поиск элемента(-ов) по ключу Методом Интерполяционного Поиска (только с сортированным множеством)\n";
	cout << "5. Произвести поиск элемента(-ов) по ключу Методом Прямого Поиска\n";
	cout << "6. Выход из программы\n\n";
	cout << "Напишите в консоль номер функции, которую вы хотите произвести: ";
	int Function;																							// Переменная, которая хранит номер действия
	cin >> Function;
	while (Function < 1 || Function > 6)
	{
		cout << "Такого номера функции нет. Напишите в консоль новый номер функции:\n\n";
		cout << "1. Вывод множества данных\n";
		cout << "2. Сортировка множества\n";
		cout << "3. Произвести поиск элемента(-ов) по ключу Методом Линейного Поиска\n";
		cout << "4. Произвести поиск элемента(-ов) по ключу Методом Интерполяционного Поиска (только с сортированным множеством)\n";
		cout << "5. Произвести поиск элемента(-ов) по ключу Методом Прямого Поиска\n";
		cout << "6. Выход из программы\n\n";
		cout << "Напишите в консоль номер функции, которую вы хотите произвести: ";
		cin >> Function;
	}
	cout << endl;
	cout << "==============================================\n\n";
	return Function;
}

int main()
{
	system("chcp 1251>nul");
	int N;																				// Количество элементов в множестве
	cout << "Введите количество элементов в множестве: ";
	cin >> N;
	while (N <= 0)
	{
		cout << "Число элементов в множестве не может быть меньше единицы. Введите новое количество элементов: ";
		cin >> N;
	}
	People* Man = new People[N];														// Выделение памяти под множество
	Man = Create_Struct(Man, N);														// Заполнение структуры элементами
	int Action = -1;																	// Переменная, которая отвечает за выполнения действия
	while (Action != 0)																	// Пока не вышли из программы
	{
		Action = Menu();																// Запрашиваем выполняемое действие
		switch (Action)
		{
		case 1:																			// Вывод множества
		{
			Print_Struct(Man, N);
			break;
		}
		case 2:																			// Сортировка множества
		{
			Man = Sort_Struct(Man, N);
			break;
		}
		case 3:																			// Метод Линейного Поиска
		{
			Linear_Search(Man, N);
			break;
		}
		case 4:																			// Метод Интерполяционного Поиска
		{
			Interpolar_Search(Man, N);
			break;
		}
		case 5:																			// Метод Прямого Поиска Подстроки в Строке
		{
			Substring_Search(Man, N);
			break;
		}
		case 6:																			// Завершение работы программы
		{
			cout << "Выход из программы...\n";
			Action = 0;
			break;
		}
		}
	}
}